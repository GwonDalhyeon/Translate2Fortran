    MODULE PROPA_RECONST_REINITIAL
    USE SURFACE_MODULE
    USE OPERATORS
    USE REINITIAL_REMESHING
    !use making

    CONTAINS 

    SUBROUTINE CONVECTION_NORMAL(TEMP,DELTA,TYP,        RET)

    TYPE(POINTPHI), POINTER :: TEMP
    REAL(8) :: DELTA
    INTEGER :: TYP
    REAL(8) :: PHI_XPLUS, PHI_XMINUS
    REAL(8) :: PHI_YPLUS, PHI_YMINUS
    REAL(8) :: PHI_ZPLUS, PHI_ZMINUS
    REAL(8) :: PHI_X, PHI_Y, PHI_Z
    REAL(8) :: RET

    CALL OCTREE_WENO(TEMP,0,DELTA,PHI_XPLUS)
    CALL OCTREE_WENO(TEMP,1,DELTA,PHI_XMINUS)
    CALL OCTREE_WENO(TEMP,2,DELTA,PHI_YPLUS)
    CALL OCTREE_WENO(TEMP,3,DELTA,PHI_YMINUS)
    CALL OCTREE_WENO(TEMP,4,DELTA,PHI_ZPLUS)
    CALL OCTREE_WENO(TEMP,5,DELTA,PHI_ZMINUS)


    IF (TYP*PHI_XPLUS>=0 .AND. TYP*PHI_XMINUS>=0) THEN
        PHI_X = PHI_XMINUS

    ELSEIF (TYP*PHI_XPLUS<=0 .AND. TYP*PHI_XMINUS<=0) THEN
        PHI_X = PHI_XPLUS

    ELSEIF (TYP*PHI_XPLUS>0 .AND. TYP*PHI_XMINUS<0) THEN
        PHI_X = 0

    ELSE
        PHI_X = PHI_XPLUS

    END IF



    IF (TYP*PHI_YPLUS>=0 .AND. TYP*PHI_YMINUS>=0) THEN
        PHI_Y = PHI_YMINUS

    ELSEIF (TYP*PHI_YPLUS<=0 .AND. TYP*PHI_YMINUS<=0) THEN
        PHI_Y = PHI_YPLUS

    ELSEIF (TYP*PHI_YPLUS>0 .AND. TYP*PHI_YMINUS<0) THEN
        PHI_Y = 0

    ELSE
        PHI_Y = PHI_YPLUS

    END IF



    IF (TYP*PHI_ZPLUS>=0 .AND. TYP*PHI_ZMINUS>=0) THEN
        PHI_Z = PHI_ZMINUS

    ELSEIF (TYP*PHI_ZPLUS<=0 .AND. TYP*PHI_ZMINUS<=0) THEN
        PHI_Z = PHI_ZPLUS

    ELSEIF (TYP*PHI_ZPLUS>0 .AND. TYP*PHI_ZMINUS<0) THEN
        PHI_Z = 0

    ELSE
        PHI_Z = PHI_ZPLUS

    END IF

    RET = SQRT(PHI_X*PHI_X + PHI_Y*PHI_Y + PHI_Z*PHI_Z)

    END SUBROUTINE


    !SUBROUTINE TREE_EXTRAPOLATION(BURNING_RATE,TYP)
    !
    !    REAL(8), ALLOCATABLE :: BURNING_RATE(*)
    !    TYPE(BOUNDARY_POINT_TRIANGLE), POINTER :: POINT_TAIL
    !    
    !    IF (TYP == 0) THEN
    !        POINT_TAIL = FLUID_POINT_TRIANGLE_TAIL
    !    END IF
    !    
    !    IF (TYP == 1) THEN
    !        POINT_TAIL = STRUCT_POINT_TRIANGLE_TAIL
    !    END IF

    SUBROUTINE TREE_PROPAGATE_SURFACE(BURNING_RATE, TYPE1)

    REAL(8) :: DELTA
    TYPE(POINTPHI), POINTER :: TEMP, HEAD
    REAL(8) :: BURNING_RATE(*)
    LOGICAL :: L
    REAL(8) :: U
    INTEGER :: TYPE1

    INTEGER :: TEMP1
    REAL(8) :: TEMP2(0)
    INTEGER :: TEMP3(0)

    TEMP1 = 0



    IF (TYPE1==0) THEN
        HEAD => FLUID_POINTPHI_HEAD
    END IF
    IF (TYPE1==1) THEN
        HEAD => CASE_POINTPHI_HEAD
    END IF
    IF (TYPE1==2) THEN
        HEAD => PROPEL_POINTPHI_HEAD
    END IF

    !CALL TREE_PROPAGATE_POINTS(BURNING_RATE,TYPE1)
    !CALL TREE_EXTRAPOLATION(BURNING_RATE, TYPE1)

    DELTA = 2.0**(-MAX_TREE_DEPTH)
    TEMP => HEAD

    DO WHILE(ASSOCIATED(TEMP))
        CALL CONVECTION_NORMAL(TEMP,DELTA,1,U)
        TEMP%K1 = TIME_STEP * -TEMP%B_RATE * U
        TEMP => TEMP%NEXT

    END DO 

    TEMP => HEAD

    DO WHILE(ASSOCIATED(TEMP))

    TEMP%TEMPPHI = TEMP%PHI
    TEMP%PHI = TEMP%TEMPPHI + TEMP%K1
    TEMP => TEMP%NEXT

    END DO 

    TEMP => HEAD

    DO WHILE(ASSOCIATED(TEMP))
        CALL CONVECTION_NORMAL(TEMP,DELTA,1,U)
        TEMP%K1 = TIME_STEP * -TEMP%B_RATE * U
        TEMP => TEMP%NEXT

    END DO 

    TEMP => HEAD

    DO WHILE(ASSOCIATED(TEMP))

    TEMP%PHI = 3.0/4.0 * TEMP%TEMPPHI + 1.0/4.0 * TEMP%PHI + 1.0/4.0 * TEMP%K1
    TEMP => TEMP%NEXT

    END DO 


    TEMP => HEAD

    DO WHILE(ASSOCIATED(TEMP))
        CALL CONVECTION_NORMAL(TEMP,DELTA,1,U)
        TEMP%K1 = TIME_STEP * -TEMP%B_RATE * U
        TEMP => TEMP%NEXT

    END DO 

    TEMP => HEAD

    DO WHILE(ASSOCIATED(TEMP))

    TEMP%PHI = 1.0/3.0 * TEMP%TEMPPHI + 2.0/3.0 * TEMP%PHI + 2.0/3.0 * TEMP%K1
    TEMP => TEMP%NEXT

    END DO     

    CALL ITER_REINITIAL_SCHEME(TYPE1)
    CALL GENERATE_TREE(TEMP1, TEMP2, TEMP1, TEMP3, FLUID_TREE_HEAD,.FALSE., TYPE1)

    CALL CHECK_REMESH(TYPE1,L)
    !IF (L) THEN
    !    CALL TREE_RECONSTRUCT_COARSE_SURFACE_2_TRIANGLE(TYPE1)
    !END IF
    !
    !DO I=1,50
    !    CALL SPRING_MOVING_POINTS_TRIANGLE(TYPE1)
    !END DO 

    END SUBROUTINE TREE_PROPAGATE_SURFACE




    SUBROUTINE ITER_TREE_SMOOTHING_SURFACE()

    DO I=1,10
        CALL TREE_SMOOTHING_SURFACE()
        CALL ITER_REINITIAL_SCHEME(0)
    END DO 

    END SUBROUTINE ITER_TREE_SMOOTHING_SURFACE



    SUBROUTINE TREE_SMOOTHING_SURFACE()

    REAL(8) :: B
    REAL(8) :: DELTA
    TYPE(POINTPHI), POINTER :: TEMP
    REAL(8) :: KAPPA
    INTEGER :: KAPPASIGN
    REAL(8) :: U

    B = 1.0

    DELTA =	2**(-MAX_TREE_DEPTH)
    TEMP => FLUID_POINTPHI_HEAD

    DO WHILE(ASSOCIATED(TEMP))
        CALL OCTREE_MEANCURV(TEMP,KAPPA)    
        CALL SIGN1(KAPPA,KAPPASIGN)
        CALL CONVECTION_NORMAL(TEMP,DELTA,-KAPPASIGN,U)
        TEMP%K1 = B* KAPPA * U
        TEMP => TEMP%NEXT
    END DO   

    TEMP => FLUID_POINTPHI_HEAD

    DO WHILE(ASSOCIATED(TEMP))
        TEMP%TEMPPHI = TEMP%PHI
        TEMP%PHI = TEMP%TEMPPHI + TEMP%K1
        TEMP => TEMP%NEXT
    END DO     

    TEMP => FLUID_POINTPHI_HEAD

    DO WHILE(ASSOCIATED(TEMP))
        CALL OCTREE_MEANCURV(TEMP,KAPPA)    
        CALL SIGN1(KAPPA,KAPPASIGN)
        CALL CONVECTION_NORMAL(TEMP,DELTA,-KAPPASIGN,U)
        TEMP%K1 = B* KAPPA * U
        TEMP => TEMP%NEXT
    END DO     

    TEMP => FLUID_POINTPHI_HEAD

    DO WHILE(ASSOCIATED(TEMP))
        TEMP%PHI = 3.0/4.0 * TEMP%TEMPPHI + 1.0/4.0 * TEMP%PHI + 1.0/4.0 * TEMP%K1
        TEMP => TEMP%NEXT
    END DO     

    TEMP => FLUID_POINTPHI_HEAD

    DO WHILE(ASSOCIATED(TEMP))
        CALL OCTREE_MEANCURV(TEMP,KAPPA)    
        CALL SIGN1(KAPPA,KAPPASIGN)
        CALL CONVECTION_NORMAL(TEMP,DELTA,-KAPPASIGN,U)
        TEMP%K1 = B* KAPPA * U
        TEMP => TEMP%NEXT
    END DO   

    TEMP => FLUID_POINTPHI_HEAD

    DO WHILE(ASSOCIATED(TEMP))
        TEMP%PHI = 1.0/3.0 * TEMP%TEMPPHI + 2.0/3.0 * TEMP%PHI + 2.0/3.0 * TEMP%K1
        TEMP => TEMP%NEXT
    END DO     


    END SUBROUTINE TREE_SMOOTHING_SURFACE



    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !!!   CONVECTION_NORMAL_POINT
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    SUBROUTINE CONVECTION_NORMAL_POINT(CURRENT,X,Y,Z,R,         VELOCITY)
    TYPE(OCTREE), POINTER :: CURRENT
    REAL(8) :: X
    REAL(8) :: Y
    REAL(8) :: Z
    REAL(8) :: R
    REAL(8) :: VELOCITY(3)

    REAL(8) :: X1 
    REAL(8) :: X2 
    REAL(8) :: Y1 
    REAL(8) :: Y2 
    REAL(8) :: Z1 
    REAL(8) :: Z2 
    REAL(8) :: L 

    REAL(8) :: PHI_X
    REAL(8) :: PHI_Y
    REAL(8) :: PHI_Z

    REAL(8) :: N

    REAL(8) :: N_X
    REAL(8) :: N_Y
    REAL(8) :: N_Z

    REAL(8) :: U
    REAL(8) :: V
    REAL(8) :: W

    REAL(8) :: TEMP1
    REAL(8) :: TEMP2
    REAL(8) :: TEMP3
    REAL(8) :: TEMP4
    REAL(8) :: TEMP5
    REAL(8) :: TEMP6
    REAL(8) :: TEMP7
    REAL(8) :: TEMP8

    X1 = CURRENT%PHI_LEFTBOTTOMBACK%X
    X2 = CURRENT%PHI_RIGHTBOTTOMBACK%X
    Y1 = CURRENT%PHI_LEFTBOTTOMBACK%Y
    Y2 = CURRENT%PHI_LEFTTOPBACK%Y
    Z1 = CURRENT%PHI_LEFTBOTTOMBACK%Z
    Z2 = CURRENT%PHI_LEFTBOTTOMFRONT%Z
    L = CURRENT%LENGTH

    CALL OCTREE_DX(CURRENT%PHI_LEFTBOTTOMBACK,TEMP1)
    CALL OCTREE_DX(CURRENT%PHI_LEFTTOPBACK,TEMP2)
    CALL OCTREE_DX(CURRENT%PHI_RIGHTBOTTOMBACK,TEMP3)
    CALL OCTREE_DX(CURRENT%PHI_RIGHTTOPBACK, TEMP4)
    CALL OCTREE_DX(CURRENT%PHI_LEFTBOTTOMFRONT, TEMP5)
    CALL OCTREE_DX(CURRENT%PHI_LEFTTOPFRONT, TEMP6)
    CALL OCTREE_DX(CURRENT%PHI_RIGHTBOTTOMFRONT, TEMP7)
    CALL OCTREE_DX(CURRENT%PHI_RIGHTTOPFRONT, TEMP8)
    PHI_X = TEMP1*(X2-X)/L*(Y2-Y)/L*(Z2-Z)/L + TEMP2*(X2-X)/L*(Y-Y1)/L*(Z2-Z)/L &
    + TEMP3*(X-X1)/L*(Y2-Y)/L*(Z2-Z)/L + TEMP4*(X-X1)/L*(Y-Y1)/L*(Z2-Z)/L &
    + TEMP5*(X2-X)/L*(Y2-Y)/L*(Z-Z1)/L + TEMP6*(X2-X)/L*(Y-Y1)/L*(Z-Z1)/L &
    + TEMP7*(X-X1)/L*(Y2-Y)/L*(Z-Z1)/L + TEMP8*(X-X1)/L*(Y-Y1)/L*(Z-Z1)/L

    CALL OCTREE_DY(CURRENT%PHI_LEFTBOTTOMBACK, TEMP1)
    CALL OCTREE_DY(CURRENT%PHI_LEFTTOPBACK, TEMP2)
    CALL OCTREE_DY(CURRENT%PHI_RIGHTBOTTOMBACK, TEMP3)
    CALL OCTREE_DY(CURRENT%PHI_RIGHTTOPBACK, TEMP4)
    CALL OCTREE_DY(CURRENT%PHI_LEFTBOTTOMFRONT, TEMP5)
    CALL OCTREE_DY(CURRENT%PHI_LEFTTOPFRONT, TEMP6)
    CALL OCTREE_DY(CURRENT%PHI_RIGHTBOTTOMFRONT, TEMP7)
    CALL OCTREE_DY(CURRENT%PHI_RIGHTTOPFRONT, TEMP8)
    PHI_Y = TEMP1*(X2-X)/L*(Y2-Y)/L*(Z2-Z)/L + TEMP2*(X2-X)/L*(Y-Y1)/L*(Z2-Z)/L &
    + TEMP3*(X-X1)/L*(Y2-Y)/L*(Z2-Z)/L + TEMP4*(X-X1)/L*(Y-Y1)/L*(Z2-Z)/L &
    + TEMP5*(X2-X)/L*(Y2-Y)/L*(Z-Z1)/L + TEMP6*(X2-X)/L*(Y-Y1)/L*(Z-Z1)/L &
    + TEMP7*(X-X1)/L*(Y2-Y)/L*(Z-Z1)/L + TEMP8*(X-X1)/L*(Y-Y1)/L*(Z-Z1)/L

    CALL OCTREE_DZ(CURRENT%PHI_LEFTBOTTOMBACK, TEMP1)
    CALL OCTREE_DZ(CURRENT%PHI_LEFTTOPBACK, TEMP2)
    CALL OCTREE_DZ(CURRENT%PHI_RIGHTBOTTOMBACK, TEMP3)
    CALL OCTREE_DZ(CURRENT%PHI_RIGHTTOPBACK, TEMP4)
    CALL OCTREE_DZ(CURRENT%PHI_LEFTBOTTOMFRONT, TEMP5)
    CALL OCTREE_DZ(CURRENT%PHI_LEFTTOPFRONT, TEMP6)
    CALL OCTREE_DZ(CURRENT%PHI_RIGHTBOTTOMFRONT, TEMP7)
    CALL OCTREE_DZ(CURRENT%PHI_RIGHTTOPFRONT, TEMP8)
    PHI_Z = TEMP1*(X2-X)/L*(Y2-Y)/L*(Z2-Z)/L + TEMP2*(X2-X)/L*(Y-Y1)/L*(Z2-Z)/L &
    + TEMP3*(X-X1)/L*(Y2-Y)/L*(Z2-Z)/L + TEMP4*(X-X1)/L*(Y-Y1)/L*(Z2-Z)/L &
    + TEMP5*(X2-X)/L*(Y2-Y)/L*(Z-Z1)/L + TEMP6*(X2-X)/L*(Y-Y1)/L*(Z-Z1)/L &
    + TEMP7*(X-X1)/L*(Y2-Y)/L*(Z-Z1)/L + TEMP8*(X-X1)/L*(Y-Y1)/L*(Z-Z1)/L

    N = SQRT(PHI_X*PHI_X + PHI_Y*PHI_Y + PHI_Z*PHI_Z)

    N_X = PHI_X/N
    N_Y = PHI_Y/N
    N_Z = PHI_Z/N

    U = R*N_X
    V = R*N_Y
    W = R*N_Z

    VELOCITY(1) = U
    VELOCITY(2) = V
    VELOCITY(3) = W

    END SUBROUTINE

    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !!!   TREE_PROPAGATE_POINTS
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    SUBROUTINE TREE_PROPAGATE_POINTS(BURNING_RATE, TYPE1)
    REAL(8) :: BURNING_RATE(*)
    INTEGER :: TYPE1
    INTEGER :: POINTSNUM
    REAL(8), ALLOCATABLE :: POINTS(:,:) 
    INTEGER :: I

    REAL(8) :: X
    REAL(8) :: Y
    REAL(8) :: Z

    TYPE(OCTREE), POINTER :: CURRENT

    REAL(8) :: R
    REAL(8) :: X_TEMP
    REAL(8) :: Y_TEMP
    REAL(8) :: Z_TEMP
    REAL(8) :: K1(3)
    REAL(8) :: VELOCITY(3)


    IF (TYPE1==0) THEN 
        POINTSNUM = FLUID_SURFACE_POINTS_NUM
        POINTS = FLUID_SURFACE_POINTS
    ELSE IF(TYPE1==1)THEN
        POINTSNUM = PROPEL_SURFACE_POINTS_NUM
        POINTS = PROPEL_SURFACE_POINTS
    ELSE IF(TYPE1==2)THEN
        POINTSNUM = CASE_SURFACE_POINTS_NUM
        POINTS = CASE_SURFACE_POINTS
    END IF


    DO I=1,POINTSNUM
        X = POINTS(1,I)
        Y = POINTS(2,I)
        Z = POINTS(3,I)

        CALL FIND_CELL_CONTAINING_POINT_TYPE(X,Y,Z,TYPE1,CURRENT)

        !R = BURNING_RATE(I)
        R = 1.

        !IF (ASSOCIATED(TREE_ALL_GRID_3D) .AND. LEVEL_COMPUTEPHI_TYPE(X,Y,Z,2) > 0) THEN
        !    R=0
        !END IF

        CALL CONVECTION_NORMAL_POINT(CURRENT, X, Y, Z, R, K1)
        K1(1) = K1(1) + TIME_STEP
        K1(2) = K1(2) + TIME_STEP
        K1(3) = K1(3) + TIME_STEP

        X_TEMP = X
        Y_TEMP = Y
        Z_TEMP = Z

        X = X + K1(1)
        Y = Y + K1(2)
        Z = Z + K1(3)

        CALL CONVECTION_NORMAL_POINT(CURRENT, X, Y, Z, R, K1)
        K1(1) = K1(1) + TIME_STEP
        K1(2) = K1(2) + TIME_STEP
        K1(3) = K1(3) + TIME_STEP

        X = 3.0/4.0*X_TEMP + 1.0/4.0*X + 1.0/4.0*K1(1)
        Y = 3.0/4.0*Y_TEMP + 1.0/4.0*Y + 1.0/4.0*K1(2)
        Z = 3.0/4.0*Z_TEMP + 1.0/4.0*Z + 1.0/4.0*K1(3)

        CALL CONVECTION_NORMAL_POINT(CURRENT, X, Y, Z, R, K1)
        K1(1) = K1(1) + TIME_STEP
        K1(2) = K1(2) + TIME_STEP
        K1(3) = K1(3) + TIME_STEP

        POINTS(1,I) = 1./3.*X_TEMP + 2./3.*X + 2./3.*K1(1);
        POINTS(2,I) = 1./3.*Y_TEMP + 2./3.*Y + 2./3.*K1(2);
        POINTS(3,I) = 1./3.*Z_TEMP + 2./3.*Z + 2./3.*K1(3);

    END DO


    END SUBROUTINE


    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !!!   ITER_REINITIAL_SCHEME
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    SUBROUTINE ITER_REINITIAL_SCHEME(TYPE1)
    TYPE(POINTPHI), POINTER :: TEMP
    REAL(8) :: DELTA
    REAL(8) :: TEMP1
    INTEGER I
    REAL(8) :: TEMP2
    INTEGER :: TYPE1
integer :: tempinteger
tempinteger=0
    
    IF (TYPE1==0) THEN
        TEMP => FLUID_POINTPHI_HEAD
    END IF
    IF (TYPE1==1) THEN
        TEMP => CASE_POINTPHI_HEAD
    END IF
    IF (TYPE1==2) THEN
        TEMP => PROPEL_POINTPHI_HEAD
    END IF

    DELTA = 2.0**(-MAX_TREE_DEPTH)

    DO WHILE (ASSOCIATED(TEMP))
        CALL SIGN2(TEMP%PHI, DELTA, TEMP1)
        TEMP%REINITIAL_SIGN = TEMP1
        tempinteger= tempinteger+1
        TEMP = TEMP%NEXT
    END DO

    DO I=1,10
        CALL REINITIAL_SCHEME(TYPE1)
    END DO

    END SUBROUTINE


    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !!!!   REINITIAL_CONSTANT
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    SUBROUTINE REINITIAL_CONSTANT(TEMP, DELTA, V)
    TYPE(POINTPHI), POINTER :: TEMP
    REAL(8) :: DELTA
    REAL(8) :: V
    REAL(8) :: TAU

    REAL(8) :: S0
    REAL(8) :: PHI_XPLUS
    REAL(8) :: PHI_XMINUS
    REAL(8) :: PHI_YPLUS
    REAL(8) :: PHI_YMINUS
    REAL(8) :: PHI_ZPLUS
    REAL(8) :: PHI_ZMINUS

    REAL(8) :: PHI_X
    REAL(8) :: PHI_Y
    REAL(8) :: PHI_Z

    TAU = MAXSIZE

    IF(ASSOCIATED(TEMP%LEFT)) THEN
        TAU = MIN(TAU, TEMP%X - TEMP%LEFT%X)
    END IF
    IF(ASSOCIATED(TEMP%RIGHT)) THEN
        TAU = MIN(TAU, TEMP%RIGHT%X - TEMP%X)
    END IF
    IF(ASSOCIATED(TEMP%BOTTOM)) THEN
        TAU = MIN(TAU, TEMP%Y - TEMP%BOTTOM%Y)
    END IF
    IF(ASSOCIATED(TEMP%TOP)) THEN
        TAU = MIN(TAU, TEMP%TOP%Y - TEMP%Y)
    END IF
    IF(ASSOCIATED(TEMP%BACK)) THEN
        TAU = MIN(TAU, TEMP%Z - TEMP%BACK%Z)
    END IF
    IF(ASSOCIATED(TEMP%FRONT)) THEN
        TAU = MIN(TAU, TEMP%FRONT%Z - TEMP%Z)
    END IF

    TAU = TAU/3.0

    S0 = TEMP%REINITIAL_SIGN
    CALL OCTREE_WENO(TEMP,0,DELTA, PHI_XPLUS)
    CALL OCTREE_WENO(TEMP,1,DELTA, PHI_XMINUS)
    CALL OCTREE_WENO(TEMP,2,DELTA, PHI_YPLUS)
    CALL OCTREE_WENO(TEMP,3,DELTA, PHI_YMINUS)
    CALL OCTREE_WENO(TEMP,4,DELTA, PHI_ZPLUS)
    CALL OCTREE_WENO(TEMP,5,DELTA, PHI_ZMINUS)

    IF(S0*PHI_XPLUS>=0 .AND. S0*PHI_XMINUS>=0) THEN
        PHI_X = PHI_XMINUS
    ELSE IF(S0*PHI_XPLUS<=0 .AND. S0*PHI_XMINUS<=0) THEN
        PHI_X = PHI_XPLUS
    ELSE IF(S0*PHI_XPLUS>0 .AND. S0*PHI_XMINUS<0) THEN
        PHI_X = 0
    ELSE IF(-(ABS(PHI_XPLUS)-ABS(PHI_XMINUS)) > 0) THEN
        PHI_X = PHI_XMINUS
    ELSE 
        PHI_X = PHI_XPLUS
    END IF


    IF(S0*PHI_YPLUS>=0 .AND. S0*PHI_YMINUS>=0) THEN
        PHI_Y = PHI_YMINUS
    ELSE IF(S0*PHI_YPLUS<=0 .AND. S0*PHI_YMINUS<=0) THEN
        PHI_Y = PHI_YPLUS
    ELSE IF(S0*PHI_YPLUS>0 .AND. S0*PHI_YMINUS<0) THEN
        PHI_Y = 0
    ELSE IF(-(ABS(PHI_YPLUS)-ABS(PHI_YMINUS)) > 0) THEN
        PHI_Y = PHI_YMINUS
    ELSE 
        PHI_Y = PHI_YPLUS
    END IF

    IF(S0*PHI_ZPLUS>=0 .AND. S0*PHI_ZMINUS>=0) THEN
        PHI_Z = PHI_ZMINUS
    ELSE IF(S0*PHI_ZPLUS<=0 .AND. S0*PHI_ZMINUS<=0) THEN
        PHI_Z = PHI_ZPLUS
    ELSE IF(S0*PHI_ZPLUS>0 .AND. S0*PHI_ZMINUS<0) THEN
        PHI_Z = 0
    ELSE IF(-(ABS(PHI_ZPLUS)-ABS(PHI_ZMINUS)) > 0) THEN
        PHI_Z = PHI_ZMINUS
    ELSE 
        PHI_Z = PHI_ZPLUS        
    END IF

    V = - S0 * TAU * (SQRT(PHI_X*PHI_X+PHI_Y*PHI_Y+PHI_Z*PHI_Z)-1)




    END SUBROUTINE




    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !!!   REINITIAL_SCHEME
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    SUBROUTINE REINITIAL_SCHEME(TYP)

    REAL(8) :: DELTA
    TYPE(POINTPHI), POINTER :: POINTPHI_HEAD
    TYPE(POINTPHI), POINTER :: TEMP
    INTEGER :: TYP

    DELTA = 2**(-MAX_TREE_DEPTH)

    IF (TYP == 0) THEN
        POINTPHI_HEAD => FLUID_POINTPHI_HEAD
    END IF

    IF (TYP == 1) THEN
        POINTPHI_HEAD => CASE_POINTPHI_HEAD
    END IF

    IF (TYP == 2) THEN
        POINTPHI_HEAD => PROPEL_POINTPHI_HEAD
    END IF

    TEMP => POINTPHI_HEAD

    DO WHILE (ASSOCIATED(TEMP))
        CALL REINITIAL_CONSTANT(TEMP,DELTA,TEMP%K1)
        TEMP => TEMP%NEXT
    END DO 

    TEMP => POINTPHI_HEAD

    DO WHILE (ASSOCIATED(TEMP))

    TEMP%TEMPPHI = TEMP%PHI
    TEMP%PHI = TEMP%TEMPPHI + TEMP%K1
    TEMP => TEMP%NEXT

    END DO 

    TEMP => POINTPHI_HEAD

    DO WHILE (ASSOCIATED(TEMP))

    CALL REINITIAL_CONSTANT(TEMP,DELTA, TEMP%K1)
    TEMP => TEMP%NEXT

    END DO 

    TEMP => POINTPHI_HEAD

    DO WHILE (ASSOCIATED(TEMP))

    TEMP%PHI = 3.0/4.0 * TEMP%TEMPPHI + 1.0/4.0 * TEMP%PHI + 1.0/4.0 * TEMP%K1
    TEMP => TEMP%NEXT

    END DO 

    TEMP => POINTPHI_HEAD

    DO WHILE (ASSOCIATED(TEMP))

    CALL REINITIAL_CONSTANT(TEMP,DELTA, TEMP%K1)
    TEMP => TEMP%NEXT

    END DO 

    TEMP => POINTPHI_HEAD

    DO WHILE (ASSOCIATED(TEMP))

    TEMP%PHI = 1.0/3.0 * TEMP%TEMPPHI + 2.0/3.0 * TEMP%PHI + 2.0/3.0 * TEMP%K1
    TEMP => TEMP%NEXT

    END DO 

    END SUBROUTINE REINITIAL_SCHEME
    END MODULE
