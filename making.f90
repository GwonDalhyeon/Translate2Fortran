MODULE MAKING
    USE SURFACE_MODULE
    USE OPERATORS
    CONTAINS
        SUBROUTINE COMPUTE_INITIAL_PHI(POINT_NUM, POINT, SURF_NUM, SURF, X,Y,Z, SURF_TYPE,       R)
        INTEGER :: POINT_NUM
        REAL(8) :: POINT(3,POINT_NUM) ! POINT(DIMENSION,POINT_NUM)
        INTEGER :: SURF_NUM
        INTEGER :: SURF(3,SURF_NUM) ! SURF(3,SURF_NUM)
        INTEGER :: SURF_TYPE
        REAL(8) :: X,Y,Z
        REAL(8) :: R
        
        CALL DISTANCE_SURF_POINT(POINT_NUM, POINT, SURF_NUM, SURF, X,Y,Z, R)
	END SUBROUTINE COMPUTE_INITIAL_PHI
    
    SUBROUTINE INITIAL_TREE_GENERATING(POINT_NUM, POINT, SURF_NUM, SURF, SURF_TYPE)
        INTEGER :: POINT_NUM
        REAL(8) :: POINT(3,POINT_NUM) ! POINT(DIMENSION,POINT_NUM)
        INTEGER :: SURF_NUM
        INTEGER :: SURF(3,SURF_NUM) ! SURF(3,SURF_NUM)
        INTEGER :: SURF_TYPE
        
        TYPE(OCTREE), POINTER :: GRID
        
        CALL INITIALIZE_TREE(POINT_NUM, POINT, SURF_NUM, SURF, SURF_TYPE)
        
        IF(SURF_TYPE==0) THEN
            GRID => FLUID_TREE_HEAD
		ELSEIF(SURF_TYPE==1) THEN
            GRID => PROPEL_TREE_HEAD
		ELSEIF(SURF_TYPE==2) THEN
            GRID => CASE_TREE_HEAD
        END IF
        
        CALL GENERATE_TREE(POINT_NUM, POINT, SURF_NUM, SURF, GRID, .TRUE., SURF_TYPE)
    
    END SUBROUTINE INITIAL_TREE_GENERATING
    
    SUBROUTINE LIPSCHITZ_COND(CURRENT,      R)
        TYPE(OCTREE), POINTER :: CURRENT
        LOGICAL :: R
        REAL(8) :: GAMMA, L, D
        
        GAMMA = 3.
        L = CURRENT%LENGTH
        
        D = ABS(CURRENT%PHI_LEFTBOTTOMBACK%PHI)
        D = MIN(D, ABS(CURRENT%PHI_RIGHTBOTTOMBACK%PHI))
        D = MIN(D, ABS(CURRENT%PHI_LEFTTOPBACK%PHI))
        D = MIN(D, ABS(CURRENT%PHI_RIGHTTOPBACK%PHI))
        D = MIN(D, ABS(CURRENT%PHI_LEFTBOTTOMFRONT%PHI))
        D = MIN(D, ABS(CURRENT%PHI_RIGHTBOTTOMFRONT%PHI))
        D = MIN(D, ABS(CURRENT%PHI_LEFTTOPFRONT%PHI))
        D = MIN(D, ABS(CURRENT%PHI_RIGHTTOPFRONT%PHI))
        
        IF(D<GAMMA*L*SQRT(3.)) THEN
            R = .TRUE.
		ELSE
            R = .FALSE.
		END IF
	END SUBROUTINE LIPSCHITZ_COND
    
    SUBROUTINE DELETELINK(CURRENT, B, SURF_TYPE)
        TYPE(POINTPHI), POINTER :: CURRENT, TAIL, HEAD
        LOGICAL :: B
        INTEGER :: SURF_TYPE
        
        IF(SURF_TYPE==0) THEN
            TAIL => FLUID_POINTPHI_TAIL
            HEAD => FLUID_POINTPHI_HEAD
		ELSEIF(SURF_TYPE==1) THEN
            TAIL => PROPEL_POINTPHI_TAIL
            HEAD => PROPEL_POINTPHI_HEAD
		ELSEIF(SURF_TYPE==2) THEN
            TAIL => CASE_POINTPHI_TAIL
            HEAD => CASE_POINTPHI_HEAD
		END IF
        
        IF(ASSOCIATED(CURRENT%BEFORE)) THEN
            CURRENT%BEFORE%NEXT => CURRENT%NEXT
		END IF
        IF(ASSOCIATED(CURRENT%NEXT)) THEN
            CURRENT%NEXT%BEFORE => CURRENT%BEFORE
		ELSEIF(ASSOCIATED(CURRENT%BEFORE)) THEN
            TAIL => CURRENT%BEFORE
		ELSE
            NULLIFY(HEAD)
            NULLIFY(TAIL)
		END IF
        
        IF(B) THEN
            IF(ASSOCIATED(CURRENT%LEFT)) THEN
                CURRENT%LEFT%RIGHT => CURRENT%RIGHT
			END IF
		    IF(ASSOCIATED(CURRENT%RIGHT)) THEN
                CURRENT%RIGHT%LEFT => CURRENT%LEFT
			END IF
		    IF(ASSOCIATED(CURRENT%BOTTOM)) THEN
                CURRENT%BOTTOM%TOP => CURRENT%TOP
			END IF
		    IF(ASSOCIATED(CURRENT%TOP)) THEN
                CURRENT%TOP%BOTTOM => CURRENT%BOTTOM
			END IF
		    IF(ASSOCIATED(CURRENT%BACK)) THEN
                CURRENT%BACK%FRONT => CURRENT%FRONT
			END IF
		    IF(ASSOCIATED(CURRENT%FRONT)) THEN
                CURRENT%FRONT%BACK => CURRENT%BACK
			END IF
		ELSE
            IF(ASSOCIATED(CURRENT%LEFT)) THEN
                NULLIFY(CURRENT%LEFT%RIGHT)
			END IF
		    IF(ASSOCIATED(CURRENT%RIGHT)) THEN
                NULLIFY(CURRENT%RIGHT%LEFT)
			END IF
		    IF(ASSOCIATED(CURRENT%BOTTOM)) THEN
                NULLIFY(CURRENT%BOTTOM%TOP)
			END IF
		    IF(ASSOCIATED(CURRENT%TOP)) THEN
                NULLIFY(CURRENT%TOP%BOTTOM)
			END IF
		    IF(ASSOCIATED(CURRENT%BACK)) THEN
                NULLIFY(CURRENT%BACK%FRONT)
			END IF
		    IF(ASSOCIATED(CURRENT%FRONT)) THEN
                NULLIFY(CURRENT%FRONT%BACK)
			END IF
		END IF
        
        IF(SURF_TYPE==0) THEN
            FLUID_POINTPHI_TAIL => TAIL
            FLUID_POINTPHI_HEAD => HEAD
        ELSE IF(SURF_TYPE==1) THEN
            PROPEL_POINTPHI_TAIL => TAIL
            PROPEL_POINTPHI_HEAD => HEAD
        ELSE IF(SURF_TYPE==2) THEN
            CASE_POINTPHI_TAIL => TAIL
            CASE_POINTPHI_HEAD => HEAD
		END IF
        
        DEALLOCATE(CURRENT)
        
	END SUBROUTINE DELETELINK
    
    SUBROUTINE DELETEOCTREE(CURRENT, SURF_TYPE)
        TYPE(OCTREE), POINTER :: CURRENT, TAIL, HEAD
        LOGICAL :: B
        INTEGER :: SURF_TYPE
        
        IF(SURF_TYPE==0) THEN
            TAIL => FLUID_TREE_TAIL
            HEAD => FLUID_TREE_HEAD
		ELSEIF(SURF_TYPE==1) THEN
            TAIL => PROPEL_TREE_TAIL
            HEAD => PROPEL_TREE_HEAD
		ELSEIF(SURF_TYPE==2) THEN
            TAIL => CASE_TREE_TAIL
            HEAD => CASE_TREE_HEAD
		END IF
        
        IF(ASSOCIATED(CURRENT%BEFORE)) THEN
            CURRENT%BEFORE%NEXT => CURRENT%NEXT
		END IF
        IF(ASSOCIATED(CURRENT%NEXT)) THEN
            CURRENT%NEXT%BEFORE => CURRENT%BEFORE
		ELSEIF(ASSOCIATED(CURRENT%BEFORE)) THEN
            TAIL => CURRENT%BEFORE
		ELSE
            NULLIFY(HEAD)
            NULLIFY(TAIL)
		END IF
        
        IF(SURF_TYPE==0) THEN
            FLUID_TREE_TAIL => TAIL
            FLUID_TREE_HEAD => HEAD
        ELSE IF(SURF_TYPE==1) THEN
            PROPEL_TREE_TAIL => TAIL
            PROPEL_TREE_HEAD => HEAD
        ELSE IF(SURF_TYPE==2) THEN
            CASE_TREE_TAIL => TAIL
            CASE_TREE_HEAD => HEAD
		END IF
        
        DEALLOCATE(CURRENT)
	END SUBROUTINE DELETEOCTREE
    
    SUBROUTINE ADDLINK(X,Y,Z,PHI,LEFT,RIGHT,BOTTOM,TOP,BACK,FRONT,SURF_TYPE,        NEWPOINT)
        TYPE(POINTPHI), POINTER :: TAIL, HEAD
        INTEGER :: SURF_TYPE
        REAL(8) :: X,Y,Z,PHI
        TYPE(POINTPHI), POINTER :: LEFT,RIGHT,BOTTOM,TOP,BACK,FRONT, NEWPOINT
        
        IF(SURF_TYPE==0) THEN
            TAIL => FLUID_POINTPHI_TAIL
            HEAD => FLUID_POINTPHI_HEAD
		ELSEIF(SURF_TYPE==1) THEN
            TAIL => PROPEL_POINTPHI_TAIL
            HEAD => PROPEL_POINTPHI_HEAD
		ELSEIF(SURF_TYPE==2) THEN
            TAIL => CASE_POINTPHI_TAIL
            HEAD => CASE_POINTPHI_HEAD
		END IF
        
        ALLOCATE(NEWPOINT)
        CALL POINTPHI_CONSTRUCT(NEWPOINT)
        IF(ASSOCIATED(TAIL)) THEN
            TAIL%NEXT => NEWPOINT
		END IF
        NEWPOINT%BEFORE => TAIL
        
        NEWPOINT%LEFT => LEFT
        NEWPOINT%RIGHT => RIGHT
        NEWPOINT%TOP => TOP
        NEWPOINT%BOTTOM => BOTTOM
        NEWPOINT%FRONT => FRONT
        NEWPOINT%BACK => BACK
        
        IF(ASSOCIATED(LEFT)) THEN
            LEFT%RIGHT => NEWPOINT
		END IF
        IF(ASSOCIATED(RIGHT)) THEN
            RIGHT%LEFT => NEWPOINT
		END IF
        IF(ASSOCIATED(BOTTOM)) THEN
            BOTTOM%TOP => NEWPOINT
		END IF
        IF(ASSOCIATED(TOP)) THEN
            TOP%BOTTOM => NEWPOINT
		END IF
        IF(ASSOCIATED(BACK)) THEN
            BACK%FRONT => NEWPOINT
		END IF
        IF(ASSOCIATED(FRONT)) THEN
            FRONT%BACK => NEWPOINT
		END IF
        
        NEWPOINT%X = X
        NEWPOINT%Y = Y
        NEWPOINT%Z = Z
        
        NEWPOINT%PHI = PHI
        NEWPOINT%B_RATE = 1.
        
        !IF(SURF_TYPE==0 .AND. ALL 들어가는 부분!!
        
        IF(.NOT. ASSOCIATED(HEAD)) THEN
            HEAD => NEWPOINT
		END IF
        TAIL => NEWPOINT
        
        IF(SURF_TYPE==0) THEN
            FLUID_POINTPHI_TAIL => TAIL
            FLUID_POINTPHI_HEAD => HEAD
        ELSE IF(SURF_TYPE==1) THEN
            PROPEL_POINTPHI_TAIL => TAIL
            PROPEL_POINTPHI_HEAD => HEAD
        ELSE IF(SURF_TYPE==2) THEN
            CASE_POINTPHI_TAIL => TAIL
            CASE_POINTPHI_HEAD => HEAD
		END IF
	END SUBROUTINE ADDLINK
    
    SUBROUTINE ADDOCTREE1(SURF_TYPE,         NEWPOINT)
        TYPE(OCTREE), POINTER :: TAIL, HEAD
        INTEGER :: SURF_TYPE
        TYPE(OCTREE), POINTER :: NEWPOINT
        
        IF(SURF_TYPE==0) THEN
            TAIL => FLUID_TREE_TAIL
            HEAD => FLUID_TREE_HEAD
		ELSEIF(SURF_TYPE==1) THEN
            TAIL => PROPEL_TREE_TAIL
            HEAD => PROPEL_TREE_HEAD
		ELSEIF(SURF_TYPE==2) THEN
            TAIL => CASE_TREE_TAIL
            HEAD => CASE_TREE_HEAD
		END IF
        
        ALLOCATE(NEWPOINT)
        CALL OCTREE_CONSTRUCT1(NEWPOINT)
        IF(ASSOCIATED(TAIL)) THEN
            TAIL%NEXT => NEWPOINT
		END IF
        NEWPOINT%BEFORE => TAIL
        
        IF(.NOT. ASSOCIATED(HEAD)) THEN
            HEAD => NEWPOINT
		END IF
        TAIL => NEWPOINT
        
        IF(SURF_TYPE==0) THEN
            FLUID_TREE_TAIL => TAIL
            FLUID_TREE_HEAD => HEAD
        ELSE IF(SURF_TYPE==1) THEN
            PROPEL_TREE_TAIL => TAIL
            PROPEL_TREE_HEAD => HEAD
        ELSE IF(SURF_TYPE==2) THEN
            CASE_TREE_TAIL => TAIL
            CASE_TREE_HEAD => HEAD
		END IF
	END SUBROUTINE ADDOCTREE1
	
    
    SUBROUTINE ADDOCTREE2(TREE_PARENT, TREE_DEPTH, TREE_LENGTH, TREE_PHI_LEFTBOTTOMBACK, TREE_PHI_LEFTTOPBACK, &
    TREE_PHI_RIGHTBOTTOMBACK, TREE_PHI_RIGHTTOPBACK, TREE_PHI_LEFTBOTTOMFRONT, TREE_PHI_LEFTTOPFRONT, &
    TREE_PHI_RIGHTBOTTOMFRONT, TREE_PHI_RIGHTTOPFRONT, SURF_TYPE,         NEWPOINT)
        TYPE(OCTREE), POINTER :: TAIL, HEAD
        INTEGER :: SURF_TYPE
        INTEGER :: TREE_DEPTH
        REAL(8) :: TREE_LENGTH
        TYPE(POINTPHI), POINTER :: TREE_PHI_LEFTBOTTOMBACK, TREE_PHI_LEFTTOPBACK, TREE_PHI_RIGHTBOTTOMBACK, TREE_PHI_RIGHTTOPBACK, &
        TREE_PHI_LEFTBOTTOMFRONT, TREE_PHI_LEFTTOPFRONT, TREE_PHI_RIGHTBOTTOMFRONT, TREE_PHI_RIGHTTOPFRONT
        TYPE(OCTREE), POINTER :: TREE_PARENT, NEWPOINT
        
        IF(SURF_TYPE==0) THEN
            TAIL => FLUID_TREE_TAIL
            HEAD => FLUID_TREE_HEAD
		ELSEIF(SURF_TYPE==1) THEN
            TAIL => PROPEL_TREE_TAIL
            HEAD => PROPEL_TREE_HEAD
		ELSEIF(SURF_TYPE==2) THEN
            TAIL => CASE_TREE_TAIL
            HEAD => CASE_TREE_HEAD
		END IF
        
        ALLOCATE(NEWPOINT)
        CALL OCTREE_CONSTRUCT2(NEWPOINT, TREE_PARENT, TREE_DEPTH, TREE_LENGTH, TREE_PHI_LEFTBOTTOMBACK, TREE_PHI_LEFTTOPBACK, &
        TREE_PHI_RIGHTBOTTOMBACK, TREE_PHI_RIGHTTOPBACK, TREE_PHI_LEFTBOTTOMFRONT, TREE_PHI_LEFTTOPFRONT, &
        TREE_PHI_RIGHTBOTTOMFRONT, TREE_PHI_RIGHTTOPFRONT)
        
        IF(ASSOCIATED(TAIL)) THEN
            TAIL%NEXT => NEWPOINT
		END IF
        NEWPOINT%BEFORE => TAIL
        
        IF(.NOT. ASSOCIATED(HEAD)) THEN
            HEAD => NEWPOINT
		END IF
        TAIL => NEWPOINT
        
        IF(SURF_TYPE==0) THEN
            FLUID_TREE_TAIL => TAIL
            FLUID_TREE_HEAD => HEAD
        ELSE IF(SURF_TYPE==1) THEN
            PROPEL_TREE_TAIL => TAIL
            PROPEL_TREE_HEAD => HEAD
        ELSE IF(SURF_TYPE==2) THEN
            CASE_TREE_TAIL => TAIL
            CASE_TREE_HEAD => HEAD
		END IF
	END SUBROUTINE ADDOCTREE2
    
    SUBROUTINE INITIALIZE_TREE(POINT_NUM, POINT, SURF_NUM, SURF, SURF_TYPE)
        INTEGER :: POINT_NUM
        REAL(8) :: POINT(3,POINT_NUM)
        INTEGER :: SURF_NUM
        INTEGER :: SURF(3,SURF_NUM)
        INTEGER :: SURF_TYPE
        TYPE(OCTREE), POINTER :: GRID
        TYPE(POINTPHI), POINTER :: INITLEFTBOTTOMBACK, INITRIGHTBOTTOMBACK, INITLEFTTOPBACK, INITRIGHTTOPBACK, &
        INITLEFTBOTTOMFRONT, INITRIGHTBOTTOMFRONT, INITLEFTTOPFRONT, INITRIGHTTOPFRONT
        REAL(8) :: X,Y,Z,PHI
        TYPE(POINTPHI), POINTER :: LEFT,RIGHT,BOTTOM,TOP,BACK,FRONT
        
        CALL ADDOCTREE1(SURF_TYPE, GRID)
        GRID%DEPTH = 0
        GRID%LENGTH = MAXSIZE
        
        X = 0.
        Y = 0.
        Z = 0.
        CALL COMPUTE_INITIAL_PHI(POINT_NUM, POINT, SURF_NUM, SURF, X,Y,Z,SURF_TYPE, PHI)
        NULLIFY(LEFT)
        NULLIFY(RIGHT)
        NULLIFY(BOTTOM)
        NULLIFY(TOP)
        NULLIFY(BACK)
        NULLIFY(FRONT)
        CALL ADDLINK(X,Y,Z,PHI,LEFT,RIGHT,BOTTOM,TOP,BACK,FRONT,SURF_TYPE, INITLEFTBOTTOMBACK)
        X = MAXSIZE
        Y = 0.
        Z = 0.
        CALL COMPUTE_INITIAL_PHI(POINT_NUM, POINT, SURF_NUM, SURF, X,Y,Z,SURF_TYPE, PHI)
        CALL ADDLINK(X,Y,Z,PHI,LEFT,RIGHT,BOTTOM,TOP,BACK,FRONT,SURF_TYPE, INITRIGHTBOTTOMBACK)
        X = 0.
        Y = MAXSIZE
        Z = 0.
        CALL COMPUTE_INITIAL_PHI(POINT_NUM, POINT, SURF_NUM, SURF, X,Y,Z,SURF_TYPE, PHI)
        CALL ADDLINK(X,Y,Z,PHI,LEFT,RIGHT,BOTTOM,TOP,BACK,FRONT,SURF_TYPE, INITLEFTTOPBACK)
        X = MAXSIZE
        Y = MAXSIZE
        Z = 0.
        CALL COMPUTE_INITIAL_PHI(POINT_NUM, POINT, SURF_NUM, SURF, X,Y,Z,SURF_TYPE, PHI)
        CALL ADDLINK(X,Y,Z,PHI,LEFT,RIGHT,BOTTOM,TOP,BACK,FRONT,SURF_TYPE, INITRIGHTTOPBACK)
        X = 0.
        Y = 0.
        Z = MAXSIZE
        CALL COMPUTE_INITIAL_PHI(POINT_NUM, POINT, SURF_NUM, SURF, X,Y,Z,SURF_TYPE, PHI)
        CALL ADDLINK(X,Y,Z,PHI,LEFT,RIGHT,BOTTOM,TOP,BACK,FRONT,SURF_TYPE, INITLEFTBOTTOMFRONT)
        X = MAXSIZE
        Y = 0.
        Z = MAXSIZE
        CALL COMPUTE_INITIAL_PHI(POINT_NUM, POINT, SURF_NUM, SURF, X,Y,Z,SURF_TYPE, PHI)
        CALL ADDLINK(X,Y,Z,PHI,LEFT,RIGHT,BOTTOM,TOP,BACK,FRONT,SURF_TYPE, INITRIGHTBOTTOMFRONT)
        X = 0.
        Y = MAXSIZE
        Z = MAXSIZE
        CALL COMPUTE_INITIAL_PHI(POINT_NUM, POINT, SURF_NUM, SURF, X,Y,Z,SURF_TYPE, PHI)
        CALL ADDLINK(X,Y,Z,PHI,LEFT,RIGHT,BOTTOM,TOP,BACK,FRONT,SURF_TYPE, INITLEFTTOPFRONT)
        X = MAXSIZE
        Y = MAXSIZE
        Z = MAXSIZE
        CALL COMPUTE_INITIAL_PHI(POINT_NUM, POINT, SURF_NUM, SURF, X,Y,Z,SURF_TYPE, PHI)
        CALL ADDLINK(X,Y,Z,PHI,LEFT,RIGHT,BOTTOM,TOP,BACK,FRONT,SURF_TYPE, INITRIGHTTOPFRONT)
        

	    INITLEFTBOTTOMBACK%RIGHT => INITRIGHTBOTTOMBACK
	    INITLEFTBOTTOMBACK%TOP => INITLEFTTOPBACK
	    INITLEFTBOTTOMBACK%FRONT => INITLEFTBOTTOMFRONT

	    INITLEFTTOPBACK%RIGHT => INITRIGHTTOPBACK
	    INITLEFTTOPBACK%BOTTOM => INITLEFTBOTTOMBACK
	    INITLEFTTOPBACK%FRONT => INITLEFTTOPFRONT
        
	    INITRIGHTBOTTOMBACK%LEFT => INITLEFTBOTTOMBACK
	    INITRIGHTBOTTOMBACK%TOP => INITRIGHTTOPBACK
	    INITRIGHTBOTTOMBACK%FRONT => INITRIGHTBOTTOMFRONT

	    INITRIGHTTOPBACK%LEFT => INITLEFTTOPBACK
	    INITRIGHTTOPBACK%BOTTOM => INITLEFTBOTTOMBACK
	    INITRIGHTTOPBACK%FRONT => INITRIGHTTOPFRONT
		
	    INITLEFTBOTTOMFRONT%RIGHT => INITRIGHTBOTTOMFRONT
	    INITLEFTBOTTOMFRONT%TOP => INITLEFTTOPFRONT
	    INITLEFTBOTTOMFRONT%BACK => INITLEFTBOTTOMBACK

	    INITLEFTTOPFRONT%RIGHT => INITRIGHTTOPFRONT
	    INITLEFTTOPFRONT%BOTTOM => INITLEFTBOTTOMFRONT
	    INITLEFTTOPFRONT%BACK => INITLEFTTOPBACK

	    INITRIGHTBOTTOMFRONT%LEFT => INITLEFTBOTTOMFRONT
	    INITRIGHTBOTTOMFRONT%TOP => INITRIGHTTOPFRONT
	    INITRIGHTBOTTOMFRONT%BACK => INITRIGHTBOTTOMBACK

	    INITRIGHTTOPFRONT%LEFT => INITLEFTTOPFRONT
	    INITRIGHTTOPFRONT%BOTTOM => INITLEFTBOTTOMFRONT
	    INITRIGHTTOPFRONT%BACK => INITRIGHTTOPBACK
		
	    GRID%PHI_LEFTBOTTOMBACK => INITLEFTBOTTOMBACK
	    GRID%PHI_LEFTTOPBACK => INITLEFTTOPBACK
	    GRID%PHI_RIGHTBOTTOMBACK => INITRIGHTBOTTOMBACK
	    GRID%PHI_RIGHTTOPBACK => INITRIGHTTOPBACK

	    GRID%PHI_LEFTBOTTOMFRONT => INITLEFTBOTTOMFRONT
	    GRID%PHI_LEFTTOPFRONT => INITLEFTTOPFRONT
	    GRID%PHI_RIGHTBOTTOMFRONT => INITRIGHTBOTTOMFRONT
	    GRID%PHI_RIGHTTOPFRONT => INITRIGHTTOPFRONT
        
	END SUBROUTINE INITIALIZE_TREE
	
    RECURSIVE SUBROUTINE GENERATE_TREE(POINT_NUM, POINT, SURF_NUM, SURF, CURRENT, B_INITIAL, SURF_TYPE)
        INTEGER :: POINT_NUM
        REAL(8) :: POINT(3,POINT_NUM)
        INTEGER :: SURF_NUM
        INTEGER :: SURF(3,SURF_NUM)
        TYPE(OCTREE), POINTER :: CURRENT
        LOGICAL :: B_INITIAL
        INTEGER :: SURF_TYPE
        LOGICAL :: B
        
        CALL LIPSCHITZ_COND(CURRENT, B)
        
        IF(.NOT. ASSOCIATED(CURRENT)) THEN
        ELSEIF(ASSOCIATED(CURRENT%TREE_LEFTBOTTOMBACK)) THEN
            IF(.NOT. B_INITIAL .AND. .NOT. B) THEN
                CALL DELETETREE(CURRENT, SURF_TYPE)
			ELSE
                CALL GENERATE_TREE(POINT_NUM, POINT, SURF_NUM, SURF, CURRENT%TREE_LEFTBOTTOMBACK, B_INITIAL, SURF_TYPE)
                CALL GENERATE_TREE(POINT_NUM, POINT, SURF_NUM, SURF, CURRENT%TREE_RIGHTBOTTOMBACK, B_INITIAL, SURF_TYPE)
                CALL GENERATE_TREE(POINT_NUM, POINT, SURF_NUM, SURF, CURRENT%TREE_LEFTTOPBACK, B_INITIAL, SURF_TYPE)
                CALL GENERATE_TREE(POINT_NUM, POINT, SURF_NUM, SURF, CURRENT%TREE_RIGHTTOPBACK, B_INITIAL, SURF_TYPE)
                CALL GENERATE_TREE(POINT_NUM, POINT, SURF_NUM, SURF, CURRENT%TREE_LEFTBOTTOMFRONT, B_INITIAL, SURF_TYPE)
                CALL GENERATE_TREE(POINT_NUM, POINT, SURF_NUM, SURF, CURRENT%TREE_RIGHTBOTTOMFRONT, B_INITIAL, SURF_TYPE)
                CALL GENERATE_TREE(POINT_NUM, POINT, SURF_NUM, SURF, CURRENT%TREE_LEFTTOPFRONT, B_INITIAL, SURF_TYPE)
                CALL GENERATE_TREE(POINT_NUM, POINT, SURF_NUM, SURF, CURRENT%TREE_RIGHTTOPFRONT, B_INITIAL, SURF_TYPE)
			END IF
		ELSEIF(CURRENT%DEPTH < MAX_TREE_DEPTH .AND. B) THEN
            CALL ADDTREE(POINT_NUM, POINT, SURF_NUM, SURF, CURRENT, B_INITIAL, SURF_TYPE)
            CALL GENERATE_TREE(POINT_NUM, POINT, SURF_NUM, SURF, CURRENT%TREE_LEFTBOTTOMBACK, B_INITIAL, SURF_TYPE)
            CALL GENERATE_TREE(POINT_NUM, POINT, SURF_NUM, SURF, CURRENT%TREE_RIGHTBOTTOMBACK, B_INITIAL, SURF_TYPE)
            CALL GENERATE_TREE(POINT_NUM, POINT, SURF_NUM, SURF, CURRENT%TREE_LEFTTOPBACK, B_INITIAL, SURF_TYPE)
            CALL GENERATE_TREE(POINT_NUM, POINT, SURF_NUM, SURF, CURRENT%TREE_RIGHTTOPBACK, B_INITIAL, SURF_TYPE)
            CALL GENERATE_TREE(POINT_NUM, POINT, SURF_NUM, SURF, CURRENT%TREE_LEFTBOTTOMFRONT, B_INITIAL, SURF_TYPE)
            CALL GENERATE_TREE(POINT_NUM, POINT, SURF_NUM, SURF, CURRENT%TREE_RIGHTBOTTOMFRONT, B_INITIAL, SURF_TYPE)
            CALL GENERATE_TREE(POINT_NUM, POINT, SURF_NUM, SURF, CURRENT%TREE_LEFTTOPFRONT, B_INITIAL, SURF_TYPE)
            CALL GENERATE_TREE(POINT_NUM, POINT, SURF_NUM, SURF, CURRENT%TREE_RIGHTTOPFRONT, B_INITIAL, SURF_TYPE)
		END IF
	END SUBROUTINE GENERATE_TREE
    
    SUBROUTINE ADDTREE(POINT_NUM, POINT, SURF_NUM, SURF, CURRENT, B_INITIAL, SURF_TYPE)
        INTEGER :: POINT_NUM
        REAL(8) :: POINT(3,POINT_NUM)
        INTEGER :: SURF_NUM
        INTEGER :: SURF(3,SURF_NUM)
        TYPE(OCTREE), POINTER :: CURRENT
        LOGICAL :: B_INITIAL
        INTEGER :: SURF_TYPE
        
        TYPE(POINTPHI), POINTER :: PHI_LEFT, PHI_RIGHT, PHI_BOTTOM, PHI_TOP, PHI_BACK, PHI_FRONT, PHI_CENTER, &
        PHI_LEFTBOTTOM, PHI_RIGHTBOTTOM, PHI_LEFTTOP, PHI_RIGHTTOP, PHI_LEFTBACK, PHI_LEFTFRONT, PHI_RIGHTBACK, PHI_RIGHTFRONT, &
        PHI_BOTTOMBACK, PHI_BOTTOMFRONT, PHI_TOPBACK, PHI_TOPFRONT
        
        REAL(8) :: X, Y, Z, L
        REAL(8) :: X1, Y1, Z1
        
        REAL(8) :: TEMP
        
        TYPE(POINTPHI), POINTER :: NULLPOINTPHI
        
        REAL(8) :: NEWLENGTH
        
        
        NULLIFY(NULLPOINTPHI)        
        
        X = CURRENT%PHI_LEFTBOTTOMBACK%X
        Y = CURRENT%PHI_LEFTBOTTOMBACK%Y
        Z = CURRENT%PHI_LEFTBOTTOMBACK%Z
        L = CURRENT%LENGTH
        
        X1 = X
        Y1 = Y
        Z1 = Z + L/2.
        CALL FIND_VERTEX(CURRENT%PHI_LEFTBOTTOMFRONT,2,X1,Y1,Z1, PHI_LEFTBOTTOM)
        IF(B_INITIAL) THEN
            CALL COMPUTE_INITIAL_PHI(POINT_NUM, POINT, SURF_NUM, SURF, X1, Y1, Z1, SURF_TYPE, TEMP)
		ELSE
            CALL COMPUTEPHI(CURRENT, X1,Y1,Z1, TEMP)
        END IF
        IF(.NOT. ASSOCIATED(PHI_LEFTBOTTOM)) THEN
            CALL ADDLINK(X1,Y1,Z1,TEMP,NULLPOINTPHI,NULLPOINTPHI,NULLPOINTPHI,NULLPOINTPHI, &
            CURRENT%PHI_LEFTBOTTOMBACK, CURRENT%PHI_LEFTBOTTOMFRONT, SURF_TYPE, PHI_LEFTBOTTOM)
		END IF
        
        X1 = X + L
        Y1 = Y
        Z1 = Z + L/2.
        CALL FIND_VERTEX(CURRENT%PHI_RIGHTBOTTOMFRONT,2,X1,Y1,Z1, PHI_RIGHTBOTTOM)
        IF(B_INITIAL) THEN
            CALL COMPUTE_INITIAL_PHI(POINT_NUM, POINT, SURF_NUM, SURF, X1, Y1, Z1, SURF_TYPE, TEMP)
		ELSE
            CALL COMPUTEPHI(CURRENT, X1,Y1,Z1, TEMP)
        END IF
        IF(.NOT. ASSOCIATED(PHI_RIGHTBOTTOM)) THEN
            CALL ADDLINK(X1,Y1,Z1,TEMP,NULLPOINTPHI,NULLPOINTPHI,NULLPOINTPHI,NULLPOINTPHI, &
            CURRENT%PHI_RIGHTBOTTOMBACK, CURRENT%PHI_RIGHTBOTTOMFRONT, SURF_TYPE, PHI_RIGHTBOTTOM)
		END IF
        
        X1 = X
        Y1 = Y + L
        Z1 = Z + L/2.
        CALL FIND_VERTEX(CURRENT%PHI_LEFTTOPFRONT,2,X1,Y1,Z1, PHI_LEFTTOP)
        IF(B_INITIAL) THEN
            CALL COMPUTE_INITIAL_PHI(POINT_NUM, POINT, SURF_NUM, SURF, X1, Y1, Z1, SURF_TYPE, TEMP)
		ELSE
            CALL COMPUTEPHI(CURRENT, X1,Y1,Z1, TEMP)
        END IF
        IF(.NOT. ASSOCIATED(PHI_LEFTTOP)) THEN
            CALL ADDLINK(X1,Y1,Z1,TEMP,NULLPOINTPHI,NULLPOINTPHI,NULLPOINTPHI,NULLPOINTPHI, &
            CURRENT%PHI_LEFTTOPBACK, CURRENT%PHI_LEFTTOPFRONT, SURF_TYPE, PHI_LEFTTOP)
		END IF
        
        X1 = X + L
        Y1 = Y + L
        Z1 = Z + L/2.
        CALL FIND_VERTEX(CURRENT%PHI_RIGHTTOPFRONT,2,X1,Y1,Z1, PHI_RIGHTTOP)
        IF(B_INITIAL) THEN
            CALL COMPUTE_INITIAL_PHI(POINT_NUM, POINT, SURF_NUM, SURF, X1, Y1, Z1, SURF_TYPE, TEMP)
		ELSE
            CALL COMPUTEPHI(CURRENT, X1,Y1,Z1, TEMP)
        END IF
        IF(.NOT. ASSOCIATED(PHI_RIGHTTOP)) THEN
            CALL ADDLINK(X1,Y1,Z1,TEMP,NULLPOINTPHI,NULLPOINTPHI,NULLPOINTPHI,NULLPOINTPHI, &
            CURRENT%PHI_RIGHTTOPBACK, CURRENT%PHI_RIGHTTOPFRONT, SURF_TYPE, PHI_RIGHTTOP)
		END IF
        
        X1 = X
        Y1 = Y + L/2.
        Z1 = Z
        CALL FIND_VERTEX(CURRENT%PHI_LEFTTOPBACK,1,X1,Y1,Z1, PHI_LEFTBACK)
        IF(B_INITIAL) THEN
            CALL COMPUTE_INITIAL_PHI(POINT_NUM, POINT, SURF_NUM, SURF, X1, Y1, Z1, SURF_TYPE, TEMP)
		ELSE
            CALL COMPUTEPHI(CURRENT, X1,Y1,Z1, TEMP)
        END IF
        IF(.NOT. ASSOCIATED(PHI_LEFTBACK)) THEN
            CALL ADDLINK(X1,Y1,Z1,TEMP,NULLPOINTPHI,NULLPOINTPHI,CURRENT%PHI_LEFTBOTTOMBACK,CURRENT%PHI_LEFTTOPBACK, &
            NULLPOINTPHI, NULLPOINTPHI, SURF_TYPE, PHI_LEFTBACK)
		END IF
        
        X1 = X
        Y1 = Y + L/2.
        Z1 = Z + L
        CALL FIND_VERTEX(CURRENT%PHI_LEFTTOPFRONT,1,X1,Y1,Z1, PHI_LEFTFRONT)
        IF(B_INITIAL) THEN
            CALL COMPUTE_INITIAL_PHI(POINT_NUM, POINT, SURF_NUM, SURF, X1, Y1, Z1, SURF_TYPE, TEMP)
		ELSE
            CALL COMPUTEPHI(CURRENT, X1,Y1,Z1, TEMP)
        END IF
        IF(.NOT. ASSOCIATED(PHI_LEFTFRONT)) THEN
            CALL ADDLINK(X1,Y1,Z1,TEMP,NULLPOINTPHI,NULLPOINTPHI,CURRENT%PHI_LEFTBOTTOMFRONT,CURRENT%PHI_LEFTTOPFRONT, &
            NULLPOINTPHI, NULLPOINTPHI, SURF_TYPE, PHI_LEFTFRONT)
		END IF
        
        X1 = X + L
        Y1 = Y + L/2.
        Z1 = Z
        CALL FIND_VERTEX(CURRENT%PHI_RIGHTTOPBACK,1,X1,Y1,Z1, PHI_RIGHTBACK)
        IF(B_INITIAL) THEN
            CALL COMPUTE_INITIAL_PHI(POINT_NUM, POINT, SURF_NUM, SURF, X1, Y1, Z1, SURF_TYPE, TEMP)
		ELSE
            CALL COMPUTEPHI(CURRENT, X1,Y1,Z1, TEMP)
        END IF
        IF(.NOT. ASSOCIATED(PHI_RIGHTBACK)) THEN
            CALL ADDLINK(X1,Y1,Z1,TEMP,NULLPOINTPHI,NULLPOINTPHI,CURRENT%PHI_RIGHTBOTTOMBACK,CURRENT%PHI_RIGHTTOPBACK, &
            NULLPOINTPHI, NULLPOINTPHI, SURF_TYPE, PHI_RIGHTBACK)
		END IF
        
        X1 = X + L
        Y1 = Y + L/2.
        Z1 = Z + L
        CALL FIND_VERTEX(CURRENT%PHI_RIGHTTOPFRONT,1,X1,Y1,Z1, PHI_RIGHTFRONT)
        IF(B_INITIAL) THEN
            CALL COMPUTE_INITIAL_PHI(POINT_NUM, POINT, SURF_NUM, SURF, X1, Y1, Z1, SURF_TYPE, TEMP)
		ELSE
            CALL COMPUTEPHI(CURRENT, X1,Y1,Z1, TEMP)
        END IF
        IF(.NOT. ASSOCIATED(PHI_RIGHTFRONT)) THEN
            CALL ADDLINK(X1,Y1,Z1,TEMP,NULLPOINTPHI,NULLPOINTPHI,CURRENT%PHI_RIGHTBOTTOMFRONT,CURRENT%PHI_RIGHTTOPFRONT, &
            NULLPOINTPHI, NULLPOINTPHI, SURF_TYPE, PHI_RIGHTFRONT)
		END IF
        
        X1 = X + L/2.
        Y1 = Y
        Z1 = Z
        CALL FIND_VERTEX(CURRENT%PHI_RIGHTBOTTOMBACK,0,X1,Y1,Z1, PHI_BOTTOMBACK)
        IF(B_INITIAL) THEN
            CALL COMPUTE_INITIAL_PHI(POINT_NUM, POINT, SURF_NUM, SURF, X1, Y1, Z1, SURF_TYPE, TEMP)
		ELSE
            CALL COMPUTEPHI(CURRENT, X1,Y1,Z1, TEMP)
        END IF
        IF(.NOT. ASSOCIATED(PHI_BOTTOMBACK)) THEN
            CALL ADDLINK(X1,Y1,Z1,TEMP,CURRENT%PHI_LEFTBOTTOMBACK,CURRENT%PHI_RIGHTBOTTOMBACK,NULLPOINTPHI,NULLPOINTPHI, &
            NULLPOINTPHI, NULLPOINTPHI, SURF_TYPE, PHI_BOTTOMBACK)
		END IF
        
        X1 = X + L/2.
        Y1 = Y
        Z1 = Z + L
        CALL FIND_VERTEX(CURRENT%PHI_RIGHTBOTTOMFRONT,0,X1,Y1,Z1, PHI_BOTTOMFRONT)
        IF(B_INITIAL) THEN
            CALL COMPUTE_INITIAL_PHI(POINT_NUM, POINT, SURF_NUM, SURF, X1, Y1, Z1, SURF_TYPE, TEMP)
		ELSE
            CALL COMPUTEPHI(CURRENT, X1,Y1,Z1, TEMP)
        END IF
        IF(.NOT. ASSOCIATED(PHI_BOTTOMFRONT)) THEN
            CALL ADDLINK(X1,Y1,Z1,TEMP,CURRENT%PHI_LEFTBOTTOMFRONT,CURRENT%PHI_RIGHTBOTTOMFRONT,NULLPOINTPHI,NULLPOINTPHI, &
            NULLPOINTPHI, NULLPOINTPHI, SURF_TYPE, PHI_BOTTOMFRONT)
		END IF
        
        X1 = X + L/2.
        Y1 = Y + L
        Z1 = Z
        CALL FIND_VERTEX(CURRENT%PHI_RIGHTTOPBACK,0,X1,Y1,Z1, PHI_TOPBACK)
        IF(B_INITIAL) THEN
            CALL COMPUTE_INITIAL_PHI(POINT_NUM, POINT, SURF_NUM, SURF, X1, Y1, Z1, SURF_TYPE, TEMP)
		ELSE
            CALL COMPUTEPHI(CURRENT, X1,Y1,Z1, TEMP)
        END IF
        IF(.NOT. ASSOCIATED(PHI_TOPBACK)) THEN
            CALL ADDLINK(X1,Y1,Z1,TEMP,CURRENT%PHI_LEFTTOPBACK,CURRENT%PHI_RIGHTTOPBACK,NULLPOINTPHI,NULLPOINTPHI, &
            NULLPOINTPHI, NULLPOINTPHI, SURF_TYPE, PHI_TOPBACK)
		END IF
        
        X1 = X + L/2.
        Y1 = Y + L
        Z1 = Z + L
        CALL FIND_VERTEX(CURRENT%PHI_RIGHTTOPFRONT,0,X1,Y1,Z1, PHI_TOPFRONT)
        IF(B_INITIAL) THEN
            CALL COMPUTE_INITIAL_PHI(POINT_NUM, POINT, SURF_NUM, SURF, X1, Y1, Z1, SURF_TYPE, TEMP)
		ELSE
            CALL COMPUTEPHI(CURRENT, X1,Y1,Z1, TEMP)
        END IF
        IF(.NOT. ASSOCIATED(PHI_TOPFRONT)) THEN
            CALL ADDLINK(X1,Y1,Z1,TEMP,CURRENT%PHI_LEFTTOPFRONT,CURRENT%PHI_RIGHTTOPFRONT,NULLPOINTPHI,NULLPOINTPHI, &
            NULLPOINTPHI, NULLPOINTPHI, SURF_TYPE, PHI_TOPFRONT)
		END IF
        
        
        X1 = X
        Y1 = Y + L/2.
        Z1 = Z + L/2.
        CALL FIND_VERTEX(CURRENT%PHI_LEFTTOPFRONT,5,X1,Y1,Z1, PHI_LEFT)
        IF(B_INITIAL) THEN
            CALL COMPUTE_INITIAL_PHI(POINT_NUM, POINT, SURF_NUM, SURF, X1, Y1, Z1, SURF_TYPE, TEMP)
		ELSE
            CALL COMPUTEPHI(CURRENT, X1,Y1,Z1, TEMP)
        END IF
        IF(.NOT. ASSOCIATED(PHI_LEFT)) THEN
            CALL ADDLINK(X1,Y1,Z1,TEMP,NULLPOINTPHI,NULLPOINTPHI,PHI_LEFTBOTTOM, PHI_LEFTTOP, &
            PHI_LEFTBACK, PHI_LEFTFRONT, SURF_TYPE, PHI_LEFT)
		END IF
        
        X1 = X + L
        Y1 = Y + L/2.
        Z1 = Z + L/2.
        CALL FIND_VERTEX(CURRENT%PHI_RIGHTTOPFRONT,5,X1,Y1,Z1, PHI_RIGHT)
        IF(B_INITIAL) THEN
            CALL COMPUTE_INITIAL_PHI(POINT_NUM, POINT, SURF_NUM, SURF, X1, Y1, Z1, SURF_TYPE, TEMP)
		ELSE
            CALL COMPUTEPHI(CURRENT, X1,Y1,Z1, TEMP)
        END IF
        IF(.NOT. ASSOCIATED(PHI_RIGHT)) THEN
            CALL ADDLINK(X1,Y1,Z1,TEMP,NULLPOINTPHI,NULLPOINTPHI,PHI_RIGHTBOTTOM, PHI_RIGHTTOP, &
            PHI_RIGHTBACK, PHI_RIGHTFRONT, SURF_TYPE, PHI_RIGHT)
		END IF
        
        X1 = X + L/2.
        Y1 = Y
        Z1 = Z + L/2.
        CALL FIND_VERTEX(CURRENT%PHI_RIGHTBOTTOMFRONT,4,X1,Y1,Z1, PHI_BOTTOM)
        IF(B_INITIAL) THEN
            CALL COMPUTE_INITIAL_PHI(POINT_NUM, POINT, SURF_NUM, SURF, X1, Y1, Z1, SURF_TYPE, TEMP)
		ELSE
            CALL COMPUTEPHI(CURRENT, X1,Y1,Z1, TEMP)
        END IF
        IF(.NOT. ASSOCIATED(PHI_BOTTOM)) THEN
            CALL ADDLINK(X1,Y1,Z1,TEMP,PHI_LEFTBOTTOM, PHI_RIGHTBOTTOM,NULLPOINTPHI,NULLPOINTPHI, &
            PHI_BOTTOMBACK, PHI_BOTTOMFRONT, SURF_TYPE, PHI_BOTTOM)
		END IF
        
        X1 = X + L/2.
        Y1 = Y + L
        Z1 = Z + L/2.
        CALL FIND_VERTEX(CURRENT%PHI_RIGHTTOPFRONT,4,X1,Y1,Z1, PHI_TOP)
        IF(B_INITIAL) THEN
            CALL COMPUTE_INITIAL_PHI(POINT_NUM, POINT, SURF_NUM, SURF, X1, Y1, Z1, SURF_TYPE, TEMP)
		ELSE
            CALL COMPUTEPHI(CURRENT, X1,Y1,Z1, TEMP)
        END IF
        IF(.NOT. ASSOCIATED(PHI_TOP)) THEN
            CALL ADDLINK(X1,Y1,Z1,TEMP,PHI_LEFTTOP, PHI_RIGHTTOP,NULLPOINTPHI,NULLPOINTPHI, &
            PHI_TOPBACK, PHI_TOPFRONT, SURF_TYPE, PHI_TOP)
		END IF
        
        X1 = X + L/2.
        Y1 = Y + L/2.
        Z1 = Z
        CALL FIND_VERTEX(CURRENT%PHI_RIGHTTOPBACK,3,X1,Y1,Z1, PHI_BACK)
        IF(B_INITIAL) THEN
            CALL COMPUTE_INITIAL_PHI(POINT_NUM, POINT, SURF_NUM, SURF, X1, Y1, Z1, SURF_TYPE, TEMP)
		ELSE
            CALL COMPUTEPHI(CURRENT, X1,Y1,Z1, TEMP)
        END IF
        IF(.NOT. ASSOCIATED(PHI_BACK)) THEN
            CALL ADDLINK(X1,Y1,Z1,TEMP,PHI_LEFTBACK, PHI_RIGHTBACK,PHI_BOTTOMBACK, PHI_TOPBACK, &
            NULLPOINTPHI,NULLPOINTPHI, SURF_TYPE, PHI_BACK)
		END IF
        
        X1 = X + L/2.
        Y1 = Y + L/2.
        Z1 = Z + L
        CALL FIND_VERTEX(CURRENT%PHI_RIGHTTOPFRONT,3,X1,Y1,Z1, PHI_FRONT)
        IF(B_INITIAL) THEN
            CALL COMPUTE_INITIAL_PHI(POINT_NUM, POINT, SURF_NUM, SURF, X1, Y1, Z1, SURF_TYPE, TEMP)
		ELSE
            CALL COMPUTEPHI(CURRENT, X1,Y1,Z1, TEMP)
        END IF
        IF(.NOT. ASSOCIATED(PHI_FRONT)) THEN
            CALL ADDLINK(X1,Y1,Z1,TEMP,PHI_LEFTFRONT, PHI_RIGHTFRONT,PHI_BOTTOMFRONT, PHI_TOPFRONT, &
            NULLPOINTPHI,NULLPOINTPHI, SURF_TYPE, PHI_FRONT)
		END IF
        
        X1 = X + L/2.
        Y1 = Y + L/2.
        Z1 = Z + L/2.
        IF(B_INITIAL) THEN
            CALL COMPUTE_INITIAL_PHI(POINT_NUM, POINT, SURF_NUM, SURF, X1, Y1, Z1, SURF_TYPE, TEMP)
		ELSE
            CALL COMPUTEPHI(CURRENT, X1,Y1,Z1, TEMP)
        END IF
        CALL ADDLINK(X1,Y1,Z1,TEMP,PHI_LEFT, PHI_RIGHT,PHI_BOTTOM, PHI_TOP, &
        PHI_BACK,PHI_FRONT, SURF_TYPE, PHI_CENTER)
        
        NEWLENGTH = CURRENT%LENGTH/2.
        CALL ADDOCTREE2(CURRENT, CURRENT%DEPTH+1, NEWLENGTH, &
        CURRENT%PHI_LEFTBOTTOMBACK, PHI_LEFTBACK, PHI_BOTTOMBACK, PHI_BACK, PHI_LEFTBOTTOM, PHI_LEFT, PHI_BOTTOM, PHI_CENTER, &
        SURF_TYPE, CURRENT%TREE_LEFTBOTTOMBACK)
        CALL ADDOCTREE2(CURRENT, CURRENT%DEPTH+1, NEWLENGTH, &
        PHI_BOTTOMBACK, PHI_BACK, CURRENT%PHI_RIGHTBOTTOMBACK, PHI_RIGHTBACK, PHI_BOTTOM, PHI_CENTER, PHI_RIGHTBOTTOM, PHI_RIGHT, &
        SURF_TYPE, CURRENT%TREE_RIGHTBOTTOMBACK)
        CALL ADDOCTREE2(CURRENT, CURRENT%DEPTH+1, NEWLENGTH, &
        PHI_LEFTBACK, CURRENT%PHI_LEFTTOPBACK, PHI_BACK, PHI_TOPBACK, PHI_LEFT, PHI_LEFTTOP, PHI_CENTER, PHI_TOP, &
        SURF_TYPE, CURRENT%TREE_LEFTTOPBACK)
        CALL ADDOCTREE2(CURRENT, CURRENT%DEPTH+1, NEWLENGTH, &
        PHI_BACK, PHI_TOPBACK, PHI_RIGHTBACK, CURRENT%PHI_RIGHTTOPBACK, PHI_CENTER, PHI_TOP, PHI_RIGHT, PHI_RIGHTTOP, &
        SURF_TYPE, CURRENT%TREE_RIGHTTOPBACK)
        
        CALL ADDOCTREE2(CURRENT, CURRENT%DEPTH+1, NEWLENGTH, &
        PHI_LEFTBOTTOM, PHI_LEFT, PHI_BOTTOM, PHI_CENTER, CURRENT%PHI_LEFTBOTTOMFRONT, PHI_LEFTFRONT, PHI_BOTTOMFRONT, PHI_FRONT, &
        SURF_TYPE, CURRENT%TREE_LEFTBOTTOMFRONT)
        CALL ADDOCTREE2(CURRENT, CURRENT%DEPTH+1, NEWLENGTH, &
        PHI_BOTTOM, PHI_CENTER, PHI_RIGHTBOTTOM, PHI_RIGHT, PHI_BOTTOMFRONT, PHI_FRONT, CURRENT%PHI_RIGHTBOTTOMFRONT, PHI_RIGHTFRONT, &
        SURF_TYPE, CURRENT%TREE_RIGHTBOTTOMFRONT)
        CALL ADDOCTREE2(CURRENT, CURRENT%DEPTH+1, NEWLENGTH, &
        PHI_LEFT, PHI_LEFTTOP, PHI_CENTER, PHI_TOP, PHI_LEFTFRONT, CURRENT%PHI_LEFTTOPFRONT, PHI_FRONT, PHI_TOPFRONT, &
        SURF_TYPE, CURRENT%TREE_LEFTTOPFRONT)
        CALL ADDOCTREE2(CURRENT, CURRENT%DEPTH+1, NEWLENGTH, &
        PHI_CENTER, PHI_TOP, PHI_RIGHT, PHI_RIGHTTOP, PHI_FRONT, PHI_TOPFRONT, PHI_RIGHTFRONT, CURRENT%PHI_RIGHTTOPFRONT, &
        SURF_TYPE, CURRENT%TREE_RIGHTTOPFRONT)
        
	END SUBROUTINE ADDTREE
    
    RECURSIVE SUBROUTINE DELETETREE(CURRENT, SURF_TYPE)
        TYPE(OCTREE), POINTER :: CURRENT
        INTEGER :: SURF_TYPE
        
        IF(ASSOCIATED(CURRENT%TREE_LEFTBOTTOMBACK%TREE_LEFTBOTTOMBACK)) THEN
            CALL DELETETREE(CURRENT%TREE_LEFTBOTTOMBACK, SURF_TYPE)
		END IF
        IF(ASSOCIATED(CURRENT%TREE_RIGHTBOTTOMBACK%TREE_LEFTBOTTOMBACK)) THEN
            CALL DELETETREE(CURRENT%TREE_RIGHTBOTTOMBACK, SURF_TYPE)
		END IF
        IF(ASSOCIATED(CURRENT%TREE_LEFTTOPBACK%TREE_LEFTBOTTOMBACK)) THEN
            CALL DELETETREE(CURRENT%TREE_LEFTTOPBACK, SURF_TYPE)
		END IF
        IF(ASSOCIATED(CURRENT%TREE_RIGHTTOPBACK%TREE_LEFTBOTTOMBACK)) THEN
            CALL DELETETREE(CURRENT%TREE_RIGHTTOPBACK, SURF_TYPE)
		END IF
        IF(ASSOCIATED(CURRENT%TREE_LEFTBOTTOMFRONT%TREE_LEFTBOTTOMBACK)) THEN
            CALL DELETETREE(CURRENT%TREE_LEFTBOTTOMFRONT, SURF_TYPE)
		END IF
        IF(ASSOCIATED(CURRENT%TREE_RIGHTBOTTOMFRONT%TREE_LEFTBOTTOMBACK)) THEN
            CALL DELETETREE(CURRENT%TREE_RIGHTBOTTOMFRONT, SURF_TYPE)
		END IF
        IF(ASSOCIATED(CURRENT%TREE_LEFTTOPFRONT%TREE_LEFTBOTTOMBACK)) THEN
            CALL DELETETREE(CURRENT%TREE_LEFTTOPFRONT, SURF_TYPE)
		END IF
        IF(ASSOCIATED(CURRENT%TREE_RIGHTTOPFRONT%TREE_LEFTBOTTOMBACK)) THEN
            CALL DELETETREE(CURRENT%TREE_RIGHTTOPFRONT, SURF_TYPE)
		END IF
        
        CALL DELETELINK(CURRENT%TREE_LEFTBOTTOMBACK%PHI_RIGHTTOPFRONT, .FALSE., SURF_TYPE)
        
        IF(.NOT. ASSOCIATED(CURRENT%TREE_LEFTBOTTOMBACK%PHI_LEFTTOPFRONT%LEFT)) THEN
            CALL DELETELINK(CURRENT%TREE_LEFTBOTTOMBACK%PHI_LEFTTOPFRONT, .FALSE., SURF_TYPE)
		END IF
        IF(.NOT. ASSOCIATED(CURRENT%TREE_LEFTBOTTOMBACK%PHI_RIGHTBOTTOMFRONT%BOTTOM)) THEN
            CALL DELETELINK(CURRENT%TREE_LEFTBOTTOMBACK%PHI_RIGHTBOTTOMFRONT, .FALSE., SURF_TYPE)
		END IF
        IF(.NOT. ASSOCIATED(CURRENT%TREE_LEFTBOTTOMBACK%PHI_RIGHTTOPBACK%BACK)) THEN
            CALL DELETELINK(CURRENT%TREE_LEFTBOTTOMBACK%PHI_RIGHTTOPBACK, .FALSE., SURF_TYPE)
		END IF
        IF(.NOT. ASSOCIATED(CURRENT%TREE_RIGHTTOPFRONT%PHI_RIGHTBOTTOMBACK%RIGHT)) THEN
            CALL DELETELINK(CURRENT%TREE_RIGHTTOPFRONT%PHI_RIGHTBOTTOMBACK, .FALSE., SURF_TYPE)
		END IF
        IF(.NOT. ASSOCIATED(CURRENT%TREE_RIGHTTOPFRONT%PHI_LEFTTOPBACK%TOP)) THEN
            CALL DELETELINK(CURRENT%TREE_RIGHTTOPFRONT%PHI_LEFTTOPBACK, .FALSE., SURF_TYPE)
		END IF
        IF(.NOT. ASSOCIATED(CURRENT%TREE_RIGHTTOPFRONT%PHI_LEFTBOTTOMFRONT%FRONT)) THEN
            CALL DELETELINK(CURRENT%TREE_RIGHTTOPFRONT%PHI_LEFTBOTTOMFRONT, .FALSE., SURF_TYPE)
		END IF
        
        !PHI_LEFTBOTTOM
        IF(.NOT. ASSOCIATED(CURRENT%TREE_LEFTBOTTOMBACK%PHI_LEFTBOTTOMFRONT%LEFT) .AND. &
        .NOT. ASSOCIATED(CURRENT%TREE_LEFTBOTTOMBACK%PHI_LEFTBOTTOMFRONT%BOTTOM)) THEN
            CALL DELETELINK(CURRENT%TREE_LEFTBOTTOMBACK%PHI_LEFTBOTTOMFRONT, .TRUE., SURF_TYPE)
		END IF
        !PHI_BOTTOMBACK
        IF(.NOT. ASSOCIATED(CURRENT%TREE_LEFTBOTTOMBACK%PHI_RIGHTBOTTOMBACK%BOTTOM) .AND. &
        .NOT. ASSOCIATED(CURRENT%TREE_LEFTBOTTOMBACK%PHI_RIGHTBOTTOMBACK%BACK)) THEN
            CALL DELETELINK(CURRENT%TREE_LEFTBOTTOMBACK%PHI_RIGHTBOTTOMBACK, .TRUE., SURF_TYPE)
		END IF
        !PHI_LEFTBACK
        IF(.NOT. ASSOCIATED(CURRENT%TREE_LEFTBOTTOMBACK%PHI_LEFTTOPBACK%LEFT) .AND. &
        .NOT. ASSOCIATED(CURRENT%TREE_LEFTBOTTOMBACK%PHI_LEFTTOPBACK%BACK)) THEN
            CALL DELETELINK(CURRENT%TREE_LEFTBOTTOMBACK%PHI_LEFTTOPBACK, .TRUE., SURF_TYPE)
		END IF
        
        !PHI_RIGHTTOP
        IF(.NOT. ASSOCIATED(CURRENT%TREE_RIGHTTOPBACK%PHI_RIGHTTOPFRONT%RIGHT) .AND. &
        .NOT. ASSOCIATED(CURRENT%TREE_RIGHTTOPBACK%PHI_RIGHTTOPFRONT%TOP)) THEN
            CALL DELETELINK(CURRENT%TREE_RIGHTTOPBACK%PHI_RIGHTTOPFRONT, .TRUE., SURF_TYPE)
		END IF
        !PHI_TOPBACK
        IF(.NOT. ASSOCIATED(CURRENT%TREE_RIGHTTOPBACK%PHI_LEFTTOPBACK%TOP) .AND. &
        .NOT. ASSOCIATED(CURRENT%TREE_RIGHTTOPBACK%PHI_LEFTTOPBACK%BACK)) THEN
            CALL DELETELINK(CURRENT%TREE_RIGHTTOPBACK%PHI_LEFTTOPBACK, .TRUE., SURF_TYPE)
		END IF
        !PHI_RIGHTBACK
        IF(.NOT. ASSOCIATED(CURRENT%TREE_RIGHTTOPBACK%PHI_RIGHTBOTTOMBACK%RIGHT) .AND. &
        .NOT. ASSOCIATED(CURRENT%TREE_RIGHTTOPBACK%PHI_LEFTTOPBACK%BACK)) THEN
            CALL DELETELINK(CURRENT%TREE_RIGHTTOPBACK%PHI_LEFTTOPBACK, .TRUE., SURF_TYPE)
		END IF
        
        !PHI_LEFTTOP
        IF(.NOT. ASSOCIATED(CURRENT%TREE_LEFTTOPFRONT%PHI_LEFTTOPBACK%LEFT) .AND. &
        .NOT. ASSOCIATED(CURRENT%TREE_LEFTTOPFRONT%PHI_LEFTTOPBACK%TOP)) THEN
            CALL DELETELINK(CURRENT%TREE_LEFTTOPFRONT%PHI_LEFTTOPBACK, .TRUE., SURF_TYPE)
		END IF
        !PHI_TOPFRONT
        IF(.NOT. ASSOCIATED(CURRENT%TREE_LEFTTOPFRONT%PHI_RIGHTTOPFRONT%TOP) .AND. &
        .NOT. ASSOCIATED(CURRENT%TREE_LEFTTOPFRONT%PHI_RIGHTTOPFRONT%FRONT)) THEN
            CALL DELETELINK(CURRENT%TREE_LEFTTOPFRONT%PHI_RIGHTTOPFRONT, .TRUE., SURF_TYPE)
		END IF
        !PHI_LEFTFRONT
        IF(.NOT. ASSOCIATED(CURRENT%TREE_LEFTTOPFRONT%PHI_LEFTBOTTOMFRONT%LEFT) .AND. &
        .NOT. ASSOCIATED(CURRENT%TREE_LEFTTOPFRONT%PHI_LEFTBOTTOMFRONT%FRONT)) THEN
            CALL DELETELINK(CURRENT%TREE_LEFTTOPFRONT%PHI_LEFTBOTTOMFRONT, .TRUE., SURF_TYPE)
		END IF
        
        !PHI_RIGHTBOTTOM
        IF(.NOT. ASSOCIATED(CURRENT%TREE_RIGHTBOTTOMFRONT%PHI_RIGHTBOTTOMBACK%RIGHT) .AND. &
        .NOT. ASSOCIATED(CURRENT%TREE_RIGHTBOTTOMFRONT%PHI_RIGHTBOTTOMBACK%BOTTOM)) THEN
            CALL DELETELINK(CURRENT%TREE_RIGHTBOTTOMFRONT%PHI_RIGHTBOTTOMBACK, .TRUE., SURF_TYPE)
		END IF
        !PHI_BOTTOMFRONT
        IF(.NOT. ASSOCIATED(CURRENT%TREE_RIGHTBOTTOMFRONT%PHI_LEFTBOTTOMFRONT%BOTTOM) .AND. &
        .NOT. ASSOCIATED(CURRENT%TREE_RIGHTBOTTOMFRONT%PHI_LEFTBOTTOMFRONT%FRONT)) THEN
            CALL DELETELINK(CURRENT%TREE_RIGHTBOTTOMFRONT%PHI_LEFTBOTTOMFRONT, .TRUE., SURF_TYPE)
		END IF
        !PHI_RIGHTFRONT
        IF(.NOT. ASSOCIATED(CURRENT%TREE_RIGHTBOTTOMFRONT%PHI_RIGHTTOPFRONT%RIGHT) .AND. &
        .NOT. ASSOCIATED(CURRENT%TREE_RIGHTBOTTOMFRONT%PHI_RIGHTTOPFRONT%FRONT)) THEN
            CALL DELETELINK(CURRENT%TREE_RIGHTBOTTOMFRONT%PHI_RIGHTTOPFRONT, .TRUE., SURF_TYPE)
		END IF
        
        CALL DELETEOCTREE(CURRENT%TREE_LEFTBOTTOMBACK, SURF_TYPE)
        CALL DELETEOCTREE(CURRENT%TREE_RIGHTBOTTOMBACK, SURF_TYPE)
        CALL DELETEOCTREE(CURRENT%TREE_LEFTTOPBACK, SURF_TYPE)
        CALL DELETEOCTREE(CURRENT%TREE_RIGHTTOPBACK, SURF_TYPE)
        CALL DELETEOCTREE(CURRENT%TREE_LEFTBOTTOMFRONT, SURF_TYPE)
        CALL DELETEOCTREE(CURRENT%TREE_RIGHTBOTTOMFRONT, SURF_TYPE)
        CALL DELETEOCTREE(CURRENT%TREE_LEFTTOPFRONT, SURF_TYPE)
        CALL DELETEOCTREE(CURRENT%TREE_RIGHTTOPFRONT, SURF_TYPE)
        
        NULLIFY(CURRENT%TREE_LEFTBOTTOMBACK)
        NULLIFY(CURRENT%TREE_RIGHTBOTTOMBACK)
        NULLIFY(CURRENT%TREE_LEFTTOPBACK)
        NULLIFY(CURRENT%TREE_RIGHTTOPBACK)
        NULLIFY(CURRENT%TREE_LEFTBOTTOMFRONT)
        NULLIFY(CURRENT%TREE_RIGHTBOTTOMFRONT)
        NULLIFY(CURRENT%TREE_LEFTTOPFRONT)
        NULLIFY(CURRENT%TREE_RIGHTTOPFRONT)
        
	END SUBROUTINE DELETETREE
    
    
    SUBROUTINE FIND_CELL_CONTAINING_POINT_TYPE(X,Y,Z,TYP,       TEMP)
        REAL(8) :: X,Y,Z
        INTEGER :: TYP
        TYPE(OCTREE), POINTER :: GRID
        TYPE(OCTREE), POINTER :: CURRENT1, CURRENT2, CURRENT3, CURRENT4, TEMP
        INTEGER :: MINI
        REAL(8) :: MINLENG
        
        IF (TYP == 0) THEN
            GRID => FLUID_TREE_HEAD
        END IF
    
        IF (TYP == 1) THEN
            GRID => CASE_TREE_HEAD
        END IF

        IF (TYP == 2) THEN
            GRID => PROPEL_TREE_HEAD
        END IF
    
        CALL FIND_LR_BT_BF_FACE(GRID,X,Y,Z,.TRUE.,.TRUE.,.TRUE.,CURRENT1)
        CALL FIND_LR_BT_BF_FACE(GRID,X,Y,Z,.FALSE.,.FALSE.,.TRUE.,CURRENT2)
        CALL FIND_LR_BT_BF_FACE(GRID,X,Y,Z,.TRUE.,.TRUE.,.FALSE.,CURRENT3)
        CALL FIND_LR_BT_BF_FACE(GRID,X,Y,Z,.FALSE.,.FALSE.,.FALSE.,CURRENT4)
    
        MINLENG = CURRENT1%LENGTH
        MINI = 1
    
        IF (CURRENT2%LENGTH < MINLENG) THEN
    
            MINI = 2
            MINLENG = CURRENT2%LENGTH
        
        END IF
    
        IF (CURRENT3%LENGTH < MINLENG) THEN
    
            MINI = 3
            MINLENG = CURRENT3%LENGTH
        
        END IF

        IF (CURRENT4%LENGTH < MINLENG) THEN
    
            MINI = 4
            MINLENG = CURRENT4%LENGTH
        
        END IF
	
	    IF (MINI==1) THEN
        
        TEMP => CURRENT1
        
        END IF
    
        IF (MINI==2) THEN
        
        TEMP => CURRENT2
        
        END IF
    
        IF (MINI==3) THEN
        
        TEMP => CURRENT3
        
        END IF
    
        IF (MINI==4) THEN
        
        TEMP => CURRENT4
        
        END IF
    
    END SUBROUTINE FIND_CELL_CONTAINING_POINT_TYPE    
    
    SUBROUTINE LEVEL_COMPUTEPHI_TYPE(X,Y,Z,TYP,         RET)
         REAL(8) :: X,Y,Z
         INTEGER :: TYP
         TYPE(OCTREE), POINTER :: TEMP
         REAL(8) :: RET
         CALL FIND_CELL_CONTAINING_POINT_TYPE(X,Y,Z,TYP, TEMP)
         CALL COMPUTEPHI(TEMP,X,Y,Z,        RET)
    END SUBROUTINE LEVEL_COMPUTEPHI_TYPE 
    
    SUBROUTINE SURFACE_CONSTRUCT(POINT_NUM, POINT, SURF_NUM, SURF, DEPTH, TIMESTEP)
        INTEGER :: POINT_NUM
        REAL(8) :: POINT(3,POINT_NUM)
        INTEGER :: SURF_NUM
        INTEGER :: SURF(3,SURF_NUM)
        INTEGER :: DEPTH
        REAL(8) :: TIMESTEP
        
        CALL INIT_RANDOM_SEED()
    
        MAX_TREE_DEPTH = DEPTH
        TIME_STEP = TIMESTEP
        
        FLUID_SURFACE_POINTS_NUM = 0
        FLUID_SURFACE_FACES_NUM = 0
        PROPEL_SURFACE_POINTS_NUM = 0
        PROPEL_SURFACE_FACES_NUM = 0
        CASE_SURFACE_POINTS_NUM = 0
        CASE_SURFACE_FACES_NUM = 0
        
        NULLIFY(FLUID_TREE_HEAD)
        NULLIFY(FLUID_TREE_TAIL)
        NULLIFY(FLUID_POINTPHI_HEAD)
        NULLIFY(FLUID_POINTPHI_HEAD)
        
        NULLIFY(PROPEL_TREE_HEAD)
        NULLIFY(PROPEL_TREE_TAIL)
        NULLIFY(PROPEL_POINTPHI_HEAD)
        NULLIFY(PROPEL_POINTPHI_HEAD)
        
        NULLIFY(CASE_TREE_HEAD)
        NULLIFY(CASE_TREE_TAIL)
        NULLIFY(CASE_POINTPHI_HEAD)
        NULLIFY(CASE_POINTPHI_HEAD)
        
        CALL INITIAL_TREE_GENERATING(POINT_NUM, POINT, SURF_NUM, SURF, 0)
    END SUBROUTINE SURFACE_CONSTRUCT

    SUBROUTINE SURFACE_DESTRUCT()
        IF(ASSOCIATED(FLUID_POINTPHI_HEAD)) THEN
        ENDIF
        IF(ASSOCIATED(FLUID_TREE_HEAD)) THEN
        ENDIF
        IF(ASSOCIATED(CASE_POINTPHI_HEAD)) THEN
        ENDIF
        IF(ASSOCIATED(CASE_TREE_HEAD)) THEN
        ENDIF
        IF(ASSOCIATED(PROPEL_POINTPHI_HEAD)) THEN
        ENDIF
        IF(ASSOCIATED(PROPEL_TREE_HEAD)) THEN
        ENDIF
    END SUBROUTINE SURFACE_DESTRUCT
END MODULE